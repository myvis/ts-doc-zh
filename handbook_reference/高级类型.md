# 高级类型
本章介绍了一些构造类型的高级方法，这些方法可以与**工具类型**一起使用

- [高级类型](#高级类型)
  - [类型保证 和 类型区分](#类型保证-和-类型区分)
  - [自定义类型保证](#自定义类型保证)
    - [使用类型判定](#使用类型判定)
    - [使用 ```in``` 操作符](#使用-in-操作符)
  - [`typeof` 类型保证](#typeof-类型保证)
  - [`instanceof` 类型保证](#instanceof-类型保证)
  - [空类型](#空类型)
    - [可选参数和属性](#可选参数和属性)
    - [类型保证 和 断言后缀](#类型保证-和-断言后缀)
  - [类型别名](#类型别名)
  - [接口 vs 类型别名](#接口-vs-类型别名)
  - [枚举成员类型](#枚举成员类型)
  - [多态的 *`this`* 类型](#多态的-this-类型)
  - [索引类型](#索引类型)

## 类型保证 和 类型区分
联合类型(Union Types)常用于某个值可能是多种类型的情况。但是如果想确切知道到底这个值是哪一种类型时，需要怎么做呢？在JavaScript中，通常使用运行时代码去判断这个值是否存在，或者说满足某种类型所对应的特定条件。
```ts
// 一个返回联合类型的变量
let pet: Fish | Bird = getSmallPet();

// ok, 能够使用 "in" 判断 "swim" 这个成员是否存在
if ("swim" in pet) {
  pet.swim();
}
// error: 但是你不能直接使用这个成员，因为不能确定是Fish还是Bird，鱼不会飞
// Property 'fly' does not exist on type 'Fish | Bird'.
if (pet.fly) {
  pet.fly();
}
```
此外，还可以使用类型断言来区分类型
```ts
// 一个返回联合类型的变量
let pet: Fish | Bird = getSmallPet();

let fishPet = pet as Fish;
let birdPet = pet as Bird;

// ok
if (fishPet.swim) {
  fishPet.swim();
} else if (birdPet.fly) {
  birdPet.fly();
}
```

然而，这不酷...

## 自定义类型保证
类型保证是在运行时对变量对类型进行判断的代码。

### 使用类型判定
类型判定可以实现类型保证，可以用一个返回"类型判定"的函数来实现
```ts
function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined;
}
```
其中，`pet is Fish` 就是类型判定，类型判定的使用方式就是"参数名 is 类型"，其中参数名来自于函数入参。

当运行 ```isFish``` 时，TypeScript会将其类型限定在Fish类型，于是可以在```if```分支中直接使用 ```Fish``` 类型的特性。值得注意的是，TypeScript不仅知道了 ```pet``` 在```if```分支中的类型，也知道了 ```else``` 分支中的类型。

```ts
// Both calls to 'swim' and 'fly' are now okay.
let pet = getSmallPet();

if (isFish(pet)) {
  pet.swim();
} else {
  pet.fly();
}
```
### 使用 ```in``` 操作符

```in``` 也能限定变量的类型。
```ts
function move(pet: Fish | Bird) {
  if ("swim" in pet) {
    return pet.swim();
  }
  return pet.fly();
}
```

## `typeof` 类型保证
下面代码将 `typeof` 封装到函数中，用以判定值的类型
```ts
function isNumber(x: any): x is number {
  return typeof x === "number";
}

function isString(x: any): x is string {
  return typeof x === "string";
}

function padLeft(value: string, padding: string | number) {
  if (isNumber(padding)) {
    return Array(padding + 1).join(" ") + value;
  }
  if (isString(padding)) {
    return padding + value;
  }
  throw new Error(`Expected string or number, got '${padding}'.`);
}
```

可能这种封装的方式有点麻烦，我们也可以直接只用内联方式

```ts
function padLeft(value: string, padding: string | number) {
  if (typeof padding === "number") {
    return Array(padding + 1).join(" ") + value;
  }
  if (typeof padding === "string") {
    return padding + value;
  }
  throw new Error(`Expected string or number, got '${padding}'.`);
}
```
`typeof` 类型保证有两种使用方式：`typeof v === "typename"` 和 `typeof v !== "typename"`，其中`typename` 是 `typeof` 操作符的返回类型之一（`undefined`、`number`、`string`、`boolean`、`bigint`、`symbol`、`object`、`function`）。虽然TypeScript编译器不会阻止你将`typeof v`的返回值与其他字符串进行比较，但这样编译器就无法进行类型保证了。

## `instanceof` 类型保证
如果熟悉JavaScript中的 `instanceof` 操作符，你大概知道本节要讲的是什么了吧。
`instanceof` 类型保证使用**类型的构造函数**进行类型限定。看看下面代码：
```ts
interface Padder {
  getPaddingString(): string;
}

class SpaceRepeatingPadder implements Padder {
  constructor(private numSpaces: number) {}
  getPaddingString() {
    return Array(this.numSpaces + 1).join(" ");
  }
}

class StringPadder implements Padder {
  constructor(private value: string) {}
  getPaddingString() {
    return this.value;
  }
}

function getRandomPadder() {
  return Math.random() < 0.5
    ? new SpaceRepeatingPadder(4)
    : new StringPadder("  ");
}

let padder: Padder = getRandomPadder();

if (padder instanceof SpaceRepeatingPadder) {
  padder;
}
if (padder instanceof StringPadder) {
  padder;
}
```
`instanceof` 操作符的右边要求是一个构造函数，TypeScript会将值的类型限制为：
1. 构造函数的原型(`prototype`)的类型
2. 上述类型的构造签名的并集

## 空类型
TypeScript 有两种特殊的类型：`null` 和 `undefined`。默认情况下，类型检查器认为 `null` 和 `undefined` 可以赋给任意类型，但 `--strictNullChecks` 可以组织这个默认行为，除非显式使用联合类型：
```ts
let exampleString = "foo";
exampleString = null;
// error: Type 'null' is not assignable to type 'string'.

let stringOrNull: string | null = "bar";
stringOrNull = null;

stringOrNull = undefined;
// error: Type 'undefined' is not assignable to type 'string | null'.
```

### 可选参数和属性
在 `--strictNullChecks` 选项下，可选参数会被自动加上 `|undefined` 类型：
```ts
function f(x: number, y?: number) {
  return x + (y ?? 0);
}

f(1, 2);
f(1);
f(1, undefined);
f(1, null); //error: Argument of type 'null' is not assignable to parameter of type 'number | undefined'.
```
可选属性也一样：
```ts
class C {
  a: number;
  b?: number;
}

let c = new C();

c.a = 12;
c.a = undefined;
// error: Type 'undefined' is not assignable to type 'number'.
c.b = 13;
c.b = undefined;
c.b = null;
// error: Type 'null' is not assignable to type 'number | undefined'.
```

### 类型保证 和 断言后缀
在使用包含空类型的联合类型时，有时需要使用**类型保证**来规避空类型的情况，比如：
```ts
function f(stringOrNull: string | null): string {
  if (stringOrNull === null) {
    return "default";
  } else {
    return stringOrNull;
  }
}
```
你也可以使用简短操作符（`??`）：
```ts
function f(stringOrNull: string | null): string {
  return stringOrNull ?? "default";
}
```

有时候编译器无法判断值的类型是 `null` 和 `undefined`，你可以使用类型断言后缀(`!`)来手动判断:
```ts
interface UserAccount {
  id: number;
  email?: string;
}

const user: UserAccount | undefined = getUser("admin");
user.id;
// error: Object is possibly 'undefined'.

if (user) {
  user.email.length;
// error: Object is possibly 'undefined'.
}

// Instead if you are sure that these objects or fields exist, the
// postfix ! lets you short circuit the nullability
user!.email!.length;
```

## 类型别名
类型别名为一个类型起一个新的名字，这有时和接口很像，但是它能够给基本类型、联合类型、元组或其他类型命名。
```ts
type Second = number;

let timeInSecond: number = 10;
let time: Second = 10;
```
实际上，类型别名并不会创建一个新类型，它只是目标类型的一个引用。与接口一样，类型别名也能使用泛型：
```ts
type Container<T> = { value: T };
```
别名也能嵌套使用：
```ts
type Tree<T> = {
  value: T;
  left?: Tree<T>;
  right?: Tree<T>;
};
```
甚至能和`交叉类型`一起使用，很酷不是吗？
```ts
type LinkedList<Type> = Type & { next: LinkedList<Type> };

interface Person {
  name: string;
}

let people: LinkedList<Person> = getDriversLicenseQueue();
people.name;
people.next.name;
people.next.next.name;
people.next.next.next.name;
```

## 接口 vs 类型别名

类型别名的功能类似于接口，但是又有点不同。接口的所有特性几乎都能在类型别名中找到，它们关键的不同在于：类型别名无法多次添加额外属性，而接口却可以多次拓展。

`interface`可以给已有的接口添加属性：
```ts
interface Window {
  title: string
}

interface Window {
  ts: import("typescript")
}

const src = 'const a = "Hello World"';
window.ts.transpileModule(src, {});
```
但类型别名一旦声明就无法修改：
```ts
type Window = {
  title: string
}

type Window = {
  ts: import("typescript")
}

// Error: Duplicate identifier 'Window'.
```
由于 `接口` 更接近于JavaScript中[对象的运行方式](https://wikipedia.org/wiki/Open/closed_principle)，我们推荐尽可能的使用接口而不是类型别名。
另一方面，如果你遇到使用接口无法构造的类型，那么可以转而结合使用联合类型或者元组等工具，用类型别名来实现。

## 枚举成员类型
正如 [枚举](../handbook/基本类型.md#枚举) 中所述，枚举成员都有一个初始字面量。

## 多态的 *`this`* 类型

*`this`* 的多态性表现为 *`this`* 的类型可以在父类和子类之间切换，如同我们熟知的 [流式接口](https://en.wikipedia.org/wiki/Fluent_interface)，通过继承来提升代码表达能力：
```ts
class BasicCalculator {
  public constructor(protected value: number = 0) {}
  public currentValue(): number {
    return this.value;
  }
  public add(operand: number): this {
    this.value += operand;
    return this;
  }
  public multiply(operand: number): this {
    this.value *= operand;
    return this;
  }
  // ... other operations go here ...
}

let v = new BasicCalculator(2).multiply(5).add(1).currentValue();
```
因为使用了 *`this`* 类型，于是你能够拓展父类的方法，而不用担心 *`this`* 的类型问题。
```ts
class ScientificCalculator extends BasicCalculator {
  public constructor(value = 0) {
    super(value);
  }
  public sin() {
    this.value = Math.sin(this.value);
    return this;
  }
  // ... other operations go here ...
}

let v = new ScientificCalculator(2).multiply(5).sin().add(1).currentValue();
```

要是没有如此多变的 *`this`* 类型，调用 `multiply(5)` 之后返回的就是`BasicCalculator` 的父类型，要知道父类型是没有 `sin` 方法的，多亏了 *`this`* 类型，他会沿着继承链找到可用的方法。

## 索引类型

有了索引类型，编译器就可以利用动态的属性名来检查代码了。回想在JavaScript中我们是怎么动态遍历对象的成员的：
```ts
function pluck(o, propertyNames) {
  return propertyNames.map((n) => o[n]);
}
```
而在TypeScript中，我们使用 **索引类型查询**（**index type query**）和 **索引访问操作符**：
```ts
function pluck<T, K extends keyof T>(o: T, propertyNames: K[]): T[K][] {
  return propertyNames.map((n) => o[n]);
}

interface Car {
  manufacturer: string;
  model: string;
  year: number;
}

let taxi: Car = {
  manufacturer: "Toyota",
  model: "Camry",
  year: 2014,
};

// Manufacturer and model are both of type string,
// so we can pluck them both into a typed string array
let makeAndModel: string[] = pluck(taxi, ["manufacturer", "model"]);

// If we try to pluck model and year, we get an
// array of a union type: (string | number)[]
let modelYear = pluck(taxi, ["model", "year"]);
```
